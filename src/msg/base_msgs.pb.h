// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: base_msgs.proto

#ifndef PROTOBUF_base_5fmsgs_2eproto__INCLUDED
#define PROTOBUF_base_5fmsgs_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace AssisiMsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_base_5fmsgs_2eproto();
void protobuf_AssignDesc_base_5fmsgs_2eproto();
void protobuf_ShutdownFile_base_5fmsgs_2eproto();

class Time;
class Header;
class Point;
class Vector3;
class Quaternion;
class Pose;
class PoseStamped;
class Twist;
class TwistStamped;
class Color;
class ColorStamped;
class Polygon;
class PolygonStamped;
class Cylinder;
class CylinderStamped;

// ===================================================================

class Time : public ::google::protobuf::Message {
 public:
  Time();
  virtual ~Time();

  Time(const Time& from);

  inline Time& operator=(const Time& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Time& default_instance();

  void Swap(Time* other);

  // implements Message ----------------------------------------------

  Time* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Time& from);
  void MergeFrom(const Time& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 sec = 1;
  inline bool has_sec() const;
  inline void clear_sec();
  static const int kSecFieldNumber = 1;
  inline ::google::protobuf::uint64 sec() const;
  inline void set_sec(::google::protobuf::uint64 value);

  // required uint64 nsec = 2;
  inline bool has_nsec() const;
  inline void clear_nsec();
  static const int kNsecFieldNumber = 2;
  inline ::google::protobuf::uint64 nsec() const;
  inline void set_nsec(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:AssisiMsg.Time)
 private:
  inline void set_has_sec();
  inline void clear_has_sec();
  inline void set_has_nsec();
  inline void clear_has_nsec();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 sec_;
  ::google::protobuf::uint64 nsec_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_base_5fmsgs_2eproto();
  friend void protobuf_AssignDesc_base_5fmsgs_2eproto();
  friend void protobuf_ShutdownFile_base_5fmsgs_2eproto();

  void InitAsDefaultInstance();
  static Time* default_instance_;
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  void Swap(Header* other);

  // implements Message ----------------------------------------------

  Header* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional .AssisiMsg.Time stamp = 2;
  inline bool has_stamp() const;
  inline void clear_stamp();
  static const int kStampFieldNumber = 2;
  inline const ::AssisiMsg::Time& stamp() const;
  inline ::AssisiMsg::Time* mutable_stamp();
  inline ::AssisiMsg::Time* release_stamp();
  inline void set_allocated_stamp(::AssisiMsg::Time* stamp);

  // optional string frame_id = 3;
  inline bool has_frame_id() const;
  inline void clear_frame_id();
  static const int kFrameIdFieldNumber = 3;
  inline const ::std::string& frame_id() const;
  inline void set_frame_id(const ::std::string& value);
  inline void set_frame_id(const char* value);
  inline void set_frame_id(const char* value, size_t size);
  inline ::std::string* mutable_frame_id();
  inline ::std::string* release_frame_id();
  inline void set_allocated_frame_id(::std::string* frame_id);

  // @@protoc_insertion_point(class_scope:AssisiMsg.Header)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_stamp();
  inline void clear_has_stamp();
  inline void set_has_frame_id();
  inline void clear_has_frame_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AssisiMsg::Time* stamp_;
  ::std::string* frame_id_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_base_5fmsgs_2eproto();
  friend void protobuf_AssignDesc_base_5fmsgs_2eproto();
  friend void protobuf_ShutdownFile_base_5fmsgs_2eproto();

  void InitAsDefaultInstance();
  static Header* default_instance_;
};
// -------------------------------------------------------------------

class Point : public ::google::protobuf::Message {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  void Swap(Point* other);

  // implements Message ----------------------------------------------

  Point* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // optional double z = 3 [default = 0];
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);

  // @@protoc_insertion_point(class_scope:AssisiMsg.Point)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double x_;
  double y_;
  double z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_base_5fmsgs_2eproto();
  friend void protobuf_AssignDesc_base_5fmsgs_2eproto();
  friend void protobuf_ShutdownFile_base_5fmsgs_2eproto();

  void InitAsDefaultInstance();
  static Point* default_instance_;
};
// -------------------------------------------------------------------

class Vector3 : public ::google::protobuf::Message {
 public:
  Vector3();
  virtual ~Vector3();

  Vector3(const Vector3& from);

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3& default_instance();

  void Swap(Vector3* other);

  // implements Message ----------------------------------------------

  Vector3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector3& from);
  void MergeFrom(const Vector3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // required double z = 3 [default = 0];
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);

  // @@protoc_insertion_point(class_scope:AssisiMsg.Vector3)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double x_;
  double y_;
  double z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_base_5fmsgs_2eproto();
  friend void protobuf_AssignDesc_base_5fmsgs_2eproto();
  friend void protobuf_ShutdownFile_base_5fmsgs_2eproto();

  void InitAsDefaultInstance();
  static Vector3* default_instance_;
};
// -------------------------------------------------------------------

class Quaternion : public ::google::protobuf::Message {
 public:
  Quaternion();
  virtual ~Quaternion();

  Quaternion(const Quaternion& from);

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Quaternion& default_instance();

  void Swap(Quaternion* other);

  // implements Message ----------------------------------------------

  Quaternion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Quaternion& from);
  void MergeFrom(const Quaternion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1 [default = 0];
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // optional double y = 2 [default = 0];
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // required double z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);

  // optional double w = 4 [default = 1];
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 4;
  inline double w() const;
  inline void set_w(double value);

  // @@protoc_insertion_point(class_scope:AssisiMsg.Quaternion)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_w();
  inline void clear_has_w();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double x_;
  double y_;
  double z_;
  double w_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_base_5fmsgs_2eproto();
  friend void protobuf_AssignDesc_base_5fmsgs_2eproto();
  friend void protobuf_ShutdownFile_base_5fmsgs_2eproto();

  void InitAsDefaultInstance();
  static Quaternion* default_instance_;
};
// -------------------------------------------------------------------

class Pose : public ::google::protobuf::Message {
 public:
  Pose();
  virtual ~Pose();

  Pose(const Pose& from);

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose& default_instance();

  void Swap(Pose* other);

  // implements Message ----------------------------------------------

  Pose* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AssisiMsg.Point position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline const ::AssisiMsg::Point& position() const;
  inline ::AssisiMsg::Point* mutable_position();
  inline ::AssisiMsg::Point* release_position();
  inline void set_allocated_position(::AssisiMsg::Point* position);

  // required .AssisiMsg.Quaternion orientation = 2;
  inline bool has_orientation() const;
  inline void clear_orientation();
  static const int kOrientationFieldNumber = 2;
  inline const ::AssisiMsg::Quaternion& orientation() const;
  inline ::AssisiMsg::Quaternion* mutable_orientation();
  inline ::AssisiMsg::Quaternion* release_orientation();
  inline void set_allocated_orientation(::AssisiMsg::Quaternion* orientation);

  // @@protoc_insertion_point(class_scope:AssisiMsg.Pose)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_orientation();
  inline void clear_has_orientation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AssisiMsg::Point* position_;
  ::AssisiMsg::Quaternion* orientation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_base_5fmsgs_2eproto();
  friend void protobuf_AssignDesc_base_5fmsgs_2eproto();
  friend void protobuf_ShutdownFile_base_5fmsgs_2eproto();

  void InitAsDefaultInstance();
  static Pose* default_instance_;
};
// -------------------------------------------------------------------

class PoseStamped : public ::google::protobuf::Message {
 public:
  PoseStamped();
  virtual ~PoseStamped();

  PoseStamped(const PoseStamped& from);

  inline PoseStamped& operator=(const PoseStamped& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PoseStamped& default_instance();

  void Swap(PoseStamped* other);

  // implements Message ----------------------------------------------

  PoseStamped* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PoseStamped& from);
  void MergeFrom(const PoseStamped& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .AssisiMsg.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::AssisiMsg::Header& header() const;
  inline ::AssisiMsg::Header* mutable_header();
  inline ::AssisiMsg::Header* release_header();
  inline void set_allocated_header(::AssisiMsg::Header* header);

  // required .AssisiMsg.Pose pose = 2;
  inline bool has_pose() const;
  inline void clear_pose();
  static const int kPoseFieldNumber = 2;
  inline const ::AssisiMsg::Pose& pose() const;
  inline ::AssisiMsg::Pose* mutable_pose();
  inline ::AssisiMsg::Pose* release_pose();
  inline void set_allocated_pose(::AssisiMsg::Pose* pose);

  // @@protoc_insertion_point(class_scope:AssisiMsg.PoseStamped)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_pose();
  inline void clear_has_pose();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AssisiMsg::Header* header_;
  ::AssisiMsg::Pose* pose_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_base_5fmsgs_2eproto();
  friend void protobuf_AssignDesc_base_5fmsgs_2eproto();
  friend void protobuf_ShutdownFile_base_5fmsgs_2eproto();

  void InitAsDefaultInstance();
  static PoseStamped* default_instance_;
};
// -------------------------------------------------------------------

class Twist : public ::google::protobuf::Message {
 public:
  Twist();
  virtual ~Twist();

  Twist(const Twist& from);

  inline Twist& operator=(const Twist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Twist& default_instance();

  void Swap(Twist* other);

  // implements Message ----------------------------------------------

  Twist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Twist& from);
  void MergeFrom(const Twist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AssisiMsg.Vector3 linear = 1;
  inline bool has_linear() const;
  inline void clear_linear();
  static const int kLinearFieldNumber = 1;
  inline const ::AssisiMsg::Vector3& linear() const;
  inline ::AssisiMsg::Vector3* mutable_linear();
  inline ::AssisiMsg::Vector3* release_linear();
  inline void set_allocated_linear(::AssisiMsg::Vector3* linear);

  // required .AssisiMsg.Vector3 angular = 2;
  inline bool has_angular() const;
  inline void clear_angular();
  static const int kAngularFieldNumber = 2;
  inline const ::AssisiMsg::Vector3& angular() const;
  inline ::AssisiMsg::Vector3* mutable_angular();
  inline ::AssisiMsg::Vector3* release_angular();
  inline void set_allocated_angular(::AssisiMsg::Vector3* angular);

  // @@protoc_insertion_point(class_scope:AssisiMsg.Twist)
 private:
  inline void set_has_linear();
  inline void clear_has_linear();
  inline void set_has_angular();
  inline void clear_has_angular();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AssisiMsg::Vector3* linear_;
  ::AssisiMsg::Vector3* angular_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_base_5fmsgs_2eproto();
  friend void protobuf_AssignDesc_base_5fmsgs_2eproto();
  friend void protobuf_ShutdownFile_base_5fmsgs_2eproto();

  void InitAsDefaultInstance();
  static Twist* default_instance_;
};
// -------------------------------------------------------------------

class TwistStamped : public ::google::protobuf::Message {
 public:
  TwistStamped();
  virtual ~TwistStamped();

  TwistStamped(const TwistStamped& from);

  inline TwistStamped& operator=(const TwistStamped& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TwistStamped& default_instance();

  void Swap(TwistStamped* other);

  // implements Message ----------------------------------------------

  TwistStamped* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TwistStamped& from);
  void MergeFrom(const TwistStamped& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .AssisiMsg.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::AssisiMsg::Header& header() const;
  inline ::AssisiMsg::Header* mutable_header();
  inline ::AssisiMsg::Header* release_header();
  inline void set_allocated_header(::AssisiMsg::Header* header);

  // required .AssisiMsg.Twist twist = 2;
  inline bool has_twist() const;
  inline void clear_twist();
  static const int kTwistFieldNumber = 2;
  inline const ::AssisiMsg::Twist& twist() const;
  inline ::AssisiMsg::Twist* mutable_twist();
  inline ::AssisiMsg::Twist* release_twist();
  inline void set_allocated_twist(::AssisiMsg::Twist* twist);

  // @@protoc_insertion_point(class_scope:AssisiMsg.TwistStamped)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_twist();
  inline void clear_has_twist();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AssisiMsg::Header* header_;
  ::AssisiMsg::Twist* twist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_base_5fmsgs_2eproto();
  friend void protobuf_AssignDesc_base_5fmsgs_2eproto();
  friend void protobuf_ShutdownFile_base_5fmsgs_2eproto();

  void InitAsDefaultInstance();
  static TwistStamped* default_instance_;
};
// -------------------------------------------------------------------

class Color : public ::google::protobuf::Message {
 public:
  Color();
  virtual ~Color();

  Color(const Color& from);

  inline Color& operator=(const Color& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Color& default_instance();

  void Swap(Color* other);

  // implements Message ----------------------------------------------

  Color* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Color& from);
  void MergeFrom(const Color& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double red = 1;
  inline bool has_red() const;
  inline void clear_red();
  static const int kRedFieldNumber = 1;
  inline double red() const;
  inline void set_red(double value);

  // required double green = 2;
  inline bool has_green() const;
  inline void clear_green();
  static const int kGreenFieldNumber = 2;
  inline double green() const;
  inline void set_green(double value);

  // required double blue = 3;
  inline bool has_blue() const;
  inline void clear_blue();
  static const int kBlueFieldNumber = 3;
  inline double blue() const;
  inline void set_blue(double value);

  // optional double alpha = 4;
  inline bool has_alpha() const;
  inline void clear_alpha();
  static const int kAlphaFieldNumber = 4;
  inline double alpha() const;
  inline void set_alpha(double value);

  // @@protoc_insertion_point(class_scope:AssisiMsg.Color)
 private:
  inline void set_has_red();
  inline void clear_has_red();
  inline void set_has_green();
  inline void clear_has_green();
  inline void set_has_blue();
  inline void clear_has_blue();
  inline void set_has_alpha();
  inline void clear_has_alpha();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double red_;
  double green_;
  double blue_;
  double alpha_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_base_5fmsgs_2eproto();
  friend void protobuf_AssignDesc_base_5fmsgs_2eproto();
  friend void protobuf_ShutdownFile_base_5fmsgs_2eproto();

  void InitAsDefaultInstance();
  static Color* default_instance_;
};
// -------------------------------------------------------------------

class ColorStamped : public ::google::protobuf::Message {
 public:
  ColorStamped();
  virtual ~ColorStamped();

  ColorStamped(const ColorStamped& from);

  inline ColorStamped& operator=(const ColorStamped& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColorStamped& default_instance();

  void Swap(ColorStamped* other);

  // implements Message ----------------------------------------------

  ColorStamped* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ColorStamped& from);
  void MergeFrom(const ColorStamped& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .AssisiMsg.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::AssisiMsg::Header& header() const;
  inline ::AssisiMsg::Header* mutable_header();
  inline ::AssisiMsg::Header* release_header();
  inline void set_allocated_header(::AssisiMsg::Header* header);

  // required .AssisiMsg.Color color = 2;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 2;
  inline const ::AssisiMsg::Color& color() const;
  inline ::AssisiMsg::Color* mutable_color();
  inline ::AssisiMsg::Color* release_color();
  inline void set_allocated_color(::AssisiMsg::Color* color);

  // @@protoc_insertion_point(class_scope:AssisiMsg.ColorStamped)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_color();
  inline void clear_has_color();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AssisiMsg::Header* header_;
  ::AssisiMsg::Color* color_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_base_5fmsgs_2eproto();
  friend void protobuf_AssignDesc_base_5fmsgs_2eproto();
  friend void protobuf_ShutdownFile_base_5fmsgs_2eproto();

  void InitAsDefaultInstance();
  static ColorStamped* default_instance_;
};
// -------------------------------------------------------------------

class Polygon : public ::google::protobuf::Message {
 public:
  Polygon();
  virtual ~Polygon();

  Polygon(const Polygon& from);

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Polygon& default_instance();

  void Swap(Polygon* other);

  // implements Message ----------------------------------------------

  Polygon* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Polygon& from);
  void MergeFrom(const Polygon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AssisiMsg.Point vertices = 1;
  inline int vertices_size() const;
  inline void clear_vertices();
  static const int kVerticesFieldNumber = 1;
  inline const ::AssisiMsg::Point& vertices(int index) const;
  inline ::AssisiMsg::Point* mutable_vertices(int index);
  inline ::AssisiMsg::Point* add_vertices();
  inline const ::google::protobuf::RepeatedPtrField< ::AssisiMsg::Point >&
      vertices() const;
  inline ::google::protobuf::RepeatedPtrField< ::AssisiMsg::Point >*
      mutable_vertices();

  // optional double height = 2 [default = 1];
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline double height() const;
  inline void set_height(double value);

  // optional double mass = 3 [default = -1];
  inline bool has_mass() const;
  inline void clear_mass();
  static const int kMassFieldNumber = 3;
  inline double mass() const;
  inline void set_mass(double value);

  // @@protoc_insertion_point(class_scope:AssisiMsg.Polygon)
 private:
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_mass();
  inline void clear_has_mass();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::AssisiMsg::Point > vertices_;
  double height_;
  double mass_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_base_5fmsgs_2eproto();
  friend void protobuf_AssignDesc_base_5fmsgs_2eproto();
  friend void protobuf_ShutdownFile_base_5fmsgs_2eproto();

  void InitAsDefaultInstance();
  static Polygon* default_instance_;
};
// -------------------------------------------------------------------

class PolygonStamped : public ::google::protobuf::Message {
 public:
  PolygonStamped();
  virtual ~PolygonStamped();

  PolygonStamped(const PolygonStamped& from);

  inline PolygonStamped& operator=(const PolygonStamped& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PolygonStamped& default_instance();

  void Swap(PolygonStamped* other);

  // implements Message ----------------------------------------------

  PolygonStamped* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PolygonStamped& from);
  void MergeFrom(const PolygonStamped& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .AssisiMsg.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::AssisiMsg::Header& header() const;
  inline ::AssisiMsg::Header* mutable_header();
  inline ::AssisiMsg::Header* release_header();
  inline void set_allocated_header(::AssisiMsg::Header* header);

  // required .AssisiMsg.Polygon polygon = 2;
  inline bool has_polygon() const;
  inline void clear_polygon();
  static const int kPolygonFieldNumber = 2;
  inline const ::AssisiMsg::Polygon& polygon() const;
  inline ::AssisiMsg::Polygon* mutable_polygon();
  inline ::AssisiMsg::Polygon* release_polygon();
  inline void set_allocated_polygon(::AssisiMsg::Polygon* polygon);

  // @@protoc_insertion_point(class_scope:AssisiMsg.PolygonStamped)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_polygon();
  inline void clear_has_polygon();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AssisiMsg::Header* header_;
  ::AssisiMsg::Polygon* polygon_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_base_5fmsgs_2eproto();
  friend void protobuf_AssignDesc_base_5fmsgs_2eproto();
  friend void protobuf_ShutdownFile_base_5fmsgs_2eproto();

  void InitAsDefaultInstance();
  static PolygonStamped* default_instance_;
};
// -------------------------------------------------------------------

class Cylinder : public ::google::protobuf::Message {
 public:
  Cylinder();
  virtual ~Cylinder();

  Cylinder(const Cylinder& from);

  inline Cylinder& operator=(const Cylinder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cylinder& default_instance();

  void Swap(Cylinder* other);

  // implements Message ----------------------------------------------

  Cylinder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cylinder& from);
  void MergeFrom(const Cylinder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double radius = 1;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 1;
  inline double radius() const;
  inline void set_radius(double value);

  // optional double height = 2 [default = 1];
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline double height() const;
  inline void set_height(double value);

  // optional double mass = 3 [default = 1];
  inline bool has_mass() const;
  inline void clear_mass();
  static const int kMassFieldNumber = 3;
  inline double mass() const;
  inline void set_mass(double value);

  // @@protoc_insertion_point(class_scope:AssisiMsg.Cylinder)
 private:
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_mass();
  inline void clear_has_mass();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double radius_;
  double height_;
  double mass_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_base_5fmsgs_2eproto();
  friend void protobuf_AssignDesc_base_5fmsgs_2eproto();
  friend void protobuf_ShutdownFile_base_5fmsgs_2eproto();

  void InitAsDefaultInstance();
  static Cylinder* default_instance_;
};
// -------------------------------------------------------------------

class CylinderStamped : public ::google::protobuf::Message {
 public:
  CylinderStamped();
  virtual ~CylinderStamped();

  CylinderStamped(const CylinderStamped& from);

  inline CylinderStamped& operator=(const CylinderStamped& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CylinderStamped& default_instance();

  void Swap(CylinderStamped* other);

  // implements Message ----------------------------------------------

  CylinderStamped* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CylinderStamped& from);
  void MergeFrom(const CylinderStamped& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .AssisiMsg.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::AssisiMsg::Header& header() const;
  inline ::AssisiMsg::Header* mutable_header();
  inline ::AssisiMsg::Header* release_header();
  inline void set_allocated_header(::AssisiMsg::Header* header);

  // required .AssisiMsg.Cylinder cylinder = 2;
  inline bool has_cylinder() const;
  inline void clear_cylinder();
  static const int kCylinderFieldNumber = 2;
  inline const ::AssisiMsg::Cylinder& cylinder() const;
  inline ::AssisiMsg::Cylinder* mutable_cylinder();
  inline ::AssisiMsg::Cylinder* release_cylinder();
  inline void set_allocated_cylinder(::AssisiMsg::Cylinder* cylinder);

  // @@protoc_insertion_point(class_scope:AssisiMsg.CylinderStamped)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_cylinder();
  inline void clear_has_cylinder();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AssisiMsg::Header* header_;
  ::AssisiMsg::Cylinder* cylinder_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_base_5fmsgs_2eproto();
  friend void protobuf_AssignDesc_base_5fmsgs_2eproto();
  friend void protobuf_ShutdownFile_base_5fmsgs_2eproto();

  void InitAsDefaultInstance();
  static CylinderStamped* default_instance_;
};
// ===================================================================


// ===================================================================

// Time

// required uint64 sec = 1;
inline bool Time::has_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Time::set_has_sec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Time::clear_has_sec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Time::clear_sec() {
  sec_ = GOOGLE_ULONGLONG(0);
  clear_has_sec();
}
inline ::google::protobuf::uint64 Time::sec() const {
  return sec_;
}
inline void Time::set_sec(::google::protobuf::uint64 value) {
  set_has_sec();
  sec_ = value;
}

// required uint64 nsec = 2;
inline bool Time::has_nsec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Time::set_has_nsec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Time::clear_has_nsec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Time::clear_nsec() {
  nsec_ = GOOGLE_ULONGLONG(0);
  clear_has_nsec();
}
inline ::google::protobuf::uint64 Time::nsec() const {
  return nsec_;
}
inline void Time::set_nsec(::google::protobuf::uint64 value) {
  set_has_nsec();
  nsec_ = value;
}

// -------------------------------------------------------------------

// Header

// optional int32 id = 1;
inline bool Header::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Header::id() const {
  return id_;
}
inline void Header::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional .AssisiMsg.Time stamp = 2;
inline bool Header::has_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_stamp() {
  if (stamp_ != NULL) stamp_->::AssisiMsg::Time::Clear();
  clear_has_stamp();
}
inline const ::AssisiMsg::Time& Header::stamp() const {
  return stamp_ != NULL ? *stamp_ : *default_instance_->stamp_;
}
inline ::AssisiMsg::Time* Header::mutable_stamp() {
  set_has_stamp();
  if (stamp_ == NULL) stamp_ = new ::AssisiMsg::Time;
  return stamp_;
}
inline ::AssisiMsg::Time* Header::release_stamp() {
  clear_has_stamp();
  ::AssisiMsg::Time* temp = stamp_;
  stamp_ = NULL;
  return temp;
}
inline void Header::set_allocated_stamp(::AssisiMsg::Time* stamp) {
  delete stamp_;
  stamp_ = stamp;
  if (stamp) {
    set_has_stamp();
  } else {
    clear_has_stamp();
  }
}

// optional string frame_id = 3;
inline bool Header::has_frame_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header::set_has_frame_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header::clear_has_frame_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header::clear_frame_id() {
  if (frame_id_ != &::google::protobuf::internal::kEmptyString) {
    frame_id_->clear();
  }
  clear_has_frame_id();
}
inline const ::std::string& Header::frame_id() const {
  return *frame_id_;
}
inline void Header::set_frame_id(const ::std::string& value) {
  set_has_frame_id();
  if (frame_id_ == &::google::protobuf::internal::kEmptyString) {
    frame_id_ = new ::std::string;
  }
  frame_id_->assign(value);
}
inline void Header::set_frame_id(const char* value) {
  set_has_frame_id();
  if (frame_id_ == &::google::protobuf::internal::kEmptyString) {
    frame_id_ = new ::std::string;
  }
  frame_id_->assign(value);
}
inline void Header::set_frame_id(const char* value, size_t size) {
  set_has_frame_id();
  if (frame_id_ == &::google::protobuf::internal::kEmptyString) {
    frame_id_ = new ::std::string;
  }
  frame_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header::mutable_frame_id() {
  set_has_frame_id();
  if (frame_id_ == &::google::protobuf::internal::kEmptyString) {
    frame_id_ = new ::std::string;
  }
  return frame_id_;
}
inline ::std::string* Header::release_frame_id() {
  clear_has_frame_id();
  if (frame_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = frame_id_;
    frame_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Header::set_allocated_frame_id(::std::string* frame_id) {
  if (frame_id_ != &::google::protobuf::internal::kEmptyString) {
    delete frame_id_;
  }
  if (frame_id) {
    set_has_frame_id();
    frame_id_ = frame_id;
  } else {
    clear_has_frame_id();
    frame_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Point

// required double x = 1;
inline bool Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Point::x() const {
  return x_;
}
inline void Point::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 2;
inline bool Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Point::y() const {
  return y_;
}
inline void Point::set_y(double value) {
  set_has_y();
  y_ = value;
}

// optional double z = 3 [default = 0];
inline bool Point::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Point::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Point::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Point::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Point::z() const {
  return z_;
}
inline void Point::set_z(double value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// Vector3

// required double x = 1;
inline bool Vector3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Vector3::x() const {
  return x_;
}
inline void Vector3::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 2;
inline bool Vector3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Vector3::y() const {
  return y_;
}
inline void Vector3::set_y(double value) {
  set_has_y();
  y_ = value;
}

// required double z = 3 [default = 0];
inline bool Vector3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Vector3::z() const {
  return z_;
}
inline void Vector3::set_z(double value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// Quaternion

// optional double x = 1 [default = 0];
inline bool Quaternion::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Quaternion::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Quaternion::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Quaternion::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Quaternion::x() const {
  return x_;
}
inline void Quaternion::set_x(double value) {
  set_has_x();
  x_ = value;
}

// optional double y = 2 [default = 0];
inline bool Quaternion::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Quaternion::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Quaternion::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Quaternion::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Quaternion::y() const {
  return y_;
}
inline void Quaternion::set_y(double value) {
  set_has_y();
  y_ = value;
}

// required double z = 3;
inline bool Quaternion::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Quaternion::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Quaternion::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Quaternion::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Quaternion::z() const {
  return z_;
}
inline void Quaternion::set_z(double value) {
  set_has_z();
  z_ = value;
}

// optional double w = 4 [default = 1];
inline bool Quaternion::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Quaternion::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Quaternion::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Quaternion::clear_w() {
  w_ = 1;
  clear_has_w();
}
inline double Quaternion::w() const {
  return w_;
}
inline void Quaternion::set_w(double value) {
  set_has_w();
  w_ = value;
}

// -------------------------------------------------------------------

// Pose

// required .AssisiMsg.Point position = 1;
inline bool Pose::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pose::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pose::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pose::clear_position() {
  if (position_ != NULL) position_->::AssisiMsg::Point::Clear();
  clear_has_position();
}
inline const ::AssisiMsg::Point& Pose::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::AssisiMsg::Point* Pose::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::AssisiMsg::Point;
  return position_;
}
inline ::AssisiMsg::Point* Pose::release_position() {
  clear_has_position();
  ::AssisiMsg::Point* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Pose::set_allocated_position(::AssisiMsg::Point* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// required .AssisiMsg.Quaternion orientation = 2;
inline bool Pose::has_orientation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pose::set_has_orientation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pose::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pose::clear_orientation() {
  if (orientation_ != NULL) orientation_->::AssisiMsg::Quaternion::Clear();
  clear_has_orientation();
}
inline const ::AssisiMsg::Quaternion& Pose::orientation() const {
  return orientation_ != NULL ? *orientation_ : *default_instance_->orientation_;
}
inline ::AssisiMsg::Quaternion* Pose::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) orientation_ = new ::AssisiMsg::Quaternion;
  return orientation_;
}
inline ::AssisiMsg::Quaternion* Pose::release_orientation() {
  clear_has_orientation();
  ::AssisiMsg::Quaternion* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline void Pose::set_allocated_orientation(::AssisiMsg::Quaternion* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
}

// -------------------------------------------------------------------

// PoseStamped

// optional .AssisiMsg.Header header = 1;
inline bool PoseStamped::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PoseStamped::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PoseStamped::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PoseStamped::clear_header() {
  if (header_ != NULL) header_->::AssisiMsg::Header::Clear();
  clear_has_header();
}
inline const ::AssisiMsg::Header& PoseStamped::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::AssisiMsg::Header* PoseStamped::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::AssisiMsg::Header;
  return header_;
}
inline ::AssisiMsg::Header* PoseStamped::release_header() {
  clear_has_header();
  ::AssisiMsg::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void PoseStamped::set_allocated_header(::AssisiMsg::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// required .AssisiMsg.Pose pose = 2;
inline bool PoseStamped::has_pose() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PoseStamped::set_has_pose() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PoseStamped::clear_has_pose() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PoseStamped::clear_pose() {
  if (pose_ != NULL) pose_->::AssisiMsg::Pose::Clear();
  clear_has_pose();
}
inline const ::AssisiMsg::Pose& PoseStamped::pose() const {
  return pose_ != NULL ? *pose_ : *default_instance_->pose_;
}
inline ::AssisiMsg::Pose* PoseStamped::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) pose_ = new ::AssisiMsg::Pose;
  return pose_;
}
inline ::AssisiMsg::Pose* PoseStamped::release_pose() {
  clear_has_pose();
  ::AssisiMsg::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline void PoseStamped::set_allocated_pose(::AssisiMsg::Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
}

// -------------------------------------------------------------------

// Twist

// required .AssisiMsg.Vector3 linear = 1;
inline bool Twist::has_linear() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Twist::set_has_linear() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Twist::clear_has_linear() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Twist::clear_linear() {
  if (linear_ != NULL) linear_->::AssisiMsg::Vector3::Clear();
  clear_has_linear();
}
inline const ::AssisiMsg::Vector3& Twist::linear() const {
  return linear_ != NULL ? *linear_ : *default_instance_->linear_;
}
inline ::AssisiMsg::Vector3* Twist::mutable_linear() {
  set_has_linear();
  if (linear_ == NULL) linear_ = new ::AssisiMsg::Vector3;
  return linear_;
}
inline ::AssisiMsg::Vector3* Twist::release_linear() {
  clear_has_linear();
  ::AssisiMsg::Vector3* temp = linear_;
  linear_ = NULL;
  return temp;
}
inline void Twist::set_allocated_linear(::AssisiMsg::Vector3* linear) {
  delete linear_;
  linear_ = linear;
  if (linear) {
    set_has_linear();
  } else {
    clear_has_linear();
  }
}

// required .AssisiMsg.Vector3 angular = 2;
inline bool Twist::has_angular() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Twist::set_has_angular() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Twist::clear_has_angular() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Twist::clear_angular() {
  if (angular_ != NULL) angular_->::AssisiMsg::Vector3::Clear();
  clear_has_angular();
}
inline const ::AssisiMsg::Vector3& Twist::angular() const {
  return angular_ != NULL ? *angular_ : *default_instance_->angular_;
}
inline ::AssisiMsg::Vector3* Twist::mutable_angular() {
  set_has_angular();
  if (angular_ == NULL) angular_ = new ::AssisiMsg::Vector3;
  return angular_;
}
inline ::AssisiMsg::Vector3* Twist::release_angular() {
  clear_has_angular();
  ::AssisiMsg::Vector3* temp = angular_;
  angular_ = NULL;
  return temp;
}
inline void Twist::set_allocated_angular(::AssisiMsg::Vector3* angular) {
  delete angular_;
  angular_ = angular;
  if (angular) {
    set_has_angular();
  } else {
    clear_has_angular();
  }
}

// -------------------------------------------------------------------

// TwistStamped

// optional .AssisiMsg.Header header = 1;
inline bool TwistStamped::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TwistStamped::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TwistStamped::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TwistStamped::clear_header() {
  if (header_ != NULL) header_->::AssisiMsg::Header::Clear();
  clear_has_header();
}
inline const ::AssisiMsg::Header& TwistStamped::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::AssisiMsg::Header* TwistStamped::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::AssisiMsg::Header;
  return header_;
}
inline ::AssisiMsg::Header* TwistStamped::release_header() {
  clear_has_header();
  ::AssisiMsg::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void TwistStamped::set_allocated_header(::AssisiMsg::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// required .AssisiMsg.Twist twist = 2;
inline bool TwistStamped::has_twist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TwistStamped::set_has_twist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TwistStamped::clear_has_twist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TwistStamped::clear_twist() {
  if (twist_ != NULL) twist_->::AssisiMsg::Twist::Clear();
  clear_has_twist();
}
inline const ::AssisiMsg::Twist& TwistStamped::twist() const {
  return twist_ != NULL ? *twist_ : *default_instance_->twist_;
}
inline ::AssisiMsg::Twist* TwistStamped::mutable_twist() {
  set_has_twist();
  if (twist_ == NULL) twist_ = new ::AssisiMsg::Twist;
  return twist_;
}
inline ::AssisiMsg::Twist* TwistStamped::release_twist() {
  clear_has_twist();
  ::AssisiMsg::Twist* temp = twist_;
  twist_ = NULL;
  return temp;
}
inline void TwistStamped::set_allocated_twist(::AssisiMsg::Twist* twist) {
  delete twist_;
  twist_ = twist;
  if (twist) {
    set_has_twist();
  } else {
    clear_has_twist();
  }
}

// -------------------------------------------------------------------

// Color

// required double red = 1;
inline bool Color::has_red() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Color::set_has_red() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Color::clear_has_red() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Color::clear_red() {
  red_ = 0;
  clear_has_red();
}
inline double Color::red() const {
  return red_;
}
inline void Color::set_red(double value) {
  set_has_red();
  red_ = value;
}

// required double green = 2;
inline bool Color::has_green() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Color::set_has_green() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Color::clear_has_green() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Color::clear_green() {
  green_ = 0;
  clear_has_green();
}
inline double Color::green() const {
  return green_;
}
inline void Color::set_green(double value) {
  set_has_green();
  green_ = value;
}

// required double blue = 3;
inline bool Color::has_blue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Color::set_has_blue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Color::clear_has_blue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Color::clear_blue() {
  blue_ = 0;
  clear_has_blue();
}
inline double Color::blue() const {
  return blue_;
}
inline void Color::set_blue(double value) {
  set_has_blue();
  blue_ = value;
}

// optional double alpha = 4;
inline bool Color::has_alpha() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Color::set_has_alpha() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Color::clear_has_alpha() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Color::clear_alpha() {
  alpha_ = 0;
  clear_has_alpha();
}
inline double Color::alpha() const {
  return alpha_;
}
inline void Color::set_alpha(double value) {
  set_has_alpha();
  alpha_ = value;
}

// -------------------------------------------------------------------

// ColorStamped

// optional .AssisiMsg.Header header = 1;
inline bool ColorStamped::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColorStamped::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColorStamped::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColorStamped::clear_header() {
  if (header_ != NULL) header_->::AssisiMsg::Header::Clear();
  clear_has_header();
}
inline const ::AssisiMsg::Header& ColorStamped::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::AssisiMsg::Header* ColorStamped::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::AssisiMsg::Header;
  return header_;
}
inline ::AssisiMsg::Header* ColorStamped::release_header() {
  clear_has_header();
  ::AssisiMsg::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ColorStamped::set_allocated_header(::AssisiMsg::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// required .AssisiMsg.Color color = 2;
inline bool ColorStamped::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColorStamped::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColorStamped::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColorStamped::clear_color() {
  if (color_ != NULL) color_->::AssisiMsg::Color::Clear();
  clear_has_color();
}
inline const ::AssisiMsg::Color& ColorStamped::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::AssisiMsg::Color* ColorStamped::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::AssisiMsg::Color;
  return color_;
}
inline ::AssisiMsg::Color* ColorStamped::release_color() {
  clear_has_color();
  ::AssisiMsg::Color* temp = color_;
  color_ = NULL;
  return temp;
}
inline void ColorStamped::set_allocated_color(::AssisiMsg::Color* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
}

// -------------------------------------------------------------------

// Polygon

// repeated .AssisiMsg.Point vertices = 1;
inline int Polygon::vertices_size() const {
  return vertices_.size();
}
inline void Polygon::clear_vertices() {
  vertices_.Clear();
}
inline const ::AssisiMsg::Point& Polygon::vertices(int index) const {
  return vertices_.Get(index);
}
inline ::AssisiMsg::Point* Polygon::mutable_vertices(int index) {
  return vertices_.Mutable(index);
}
inline ::AssisiMsg::Point* Polygon::add_vertices() {
  return vertices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AssisiMsg::Point >&
Polygon::vertices() const {
  return vertices_;
}
inline ::google::protobuf::RepeatedPtrField< ::AssisiMsg::Point >*
Polygon::mutable_vertices() {
  return &vertices_;
}

// optional double height = 2 [default = 1];
inline bool Polygon::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Polygon::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Polygon::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Polygon::clear_height() {
  height_ = 1;
  clear_has_height();
}
inline double Polygon::height() const {
  return height_;
}
inline void Polygon::set_height(double value) {
  set_has_height();
  height_ = value;
}

// optional double mass = 3 [default = -1];
inline bool Polygon::has_mass() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Polygon::set_has_mass() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Polygon::clear_has_mass() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Polygon::clear_mass() {
  mass_ = -1;
  clear_has_mass();
}
inline double Polygon::mass() const {
  return mass_;
}
inline void Polygon::set_mass(double value) {
  set_has_mass();
  mass_ = value;
}

// -------------------------------------------------------------------

// PolygonStamped

// optional .AssisiMsg.Header header = 1;
inline bool PolygonStamped::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PolygonStamped::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PolygonStamped::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PolygonStamped::clear_header() {
  if (header_ != NULL) header_->::AssisiMsg::Header::Clear();
  clear_has_header();
}
inline const ::AssisiMsg::Header& PolygonStamped::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::AssisiMsg::Header* PolygonStamped::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::AssisiMsg::Header;
  return header_;
}
inline ::AssisiMsg::Header* PolygonStamped::release_header() {
  clear_has_header();
  ::AssisiMsg::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void PolygonStamped::set_allocated_header(::AssisiMsg::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// required .AssisiMsg.Polygon polygon = 2;
inline bool PolygonStamped::has_polygon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PolygonStamped::set_has_polygon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PolygonStamped::clear_has_polygon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PolygonStamped::clear_polygon() {
  if (polygon_ != NULL) polygon_->::AssisiMsg::Polygon::Clear();
  clear_has_polygon();
}
inline const ::AssisiMsg::Polygon& PolygonStamped::polygon() const {
  return polygon_ != NULL ? *polygon_ : *default_instance_->polygon_;
}
inline ::AssisiMsg::Polygon* PolygonStamped::mutable_polygon() {
  set_has_polygon();
  if (polygon_ == NULL) polygon_ = new ::AssisiMsg::Polygon;
  return polygon_;
}
inline ::AssisiMsg::Polygon* PolygonStamped::release_polygon() {
  clear_has_polygon();
  ::AssisiMsg::Polygon* temp = polygon_;
  polygon_ = NULL;
  return temp;
}
inline void PolygonStamped::set_allocated_polygon(::AssisiMsg::Polygon* polygon) {
  delete polygon_;
  polygon_ = polygon;
  if (polygon) {
    set_has_polygon();
  } else {
    clear_has_polygon();
  }
}

// -------------------------------------------------------------------

// Cylinder

// required double radius = 1;
inline bool Cylinder::has_radius() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cylinder::set_has_radius() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Cylinder::clear_has_radius() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Cylinder::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline double Cylinder::radius() const {
  return radius_;
}
inline void Cylinder::set_radius(double value) {
  set_has_radius();
  radius_ = value;
}

// optional double height = 2 [default = 1];
inline bool Cylinder::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Cylinder::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Cylinder::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Cylinder::clear_height() {
  height_ = 1;
  clear_has_height();
}
inline double Cylinder::height() const {
  return height_;
}
inline void Cylinder::set_height(double value) {
  set_has_height();
  height_ = value;
}

// optional double mass = 3 [default = 1];
inline bool Cylinder::has_mass() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Cylinder::set_has_mass() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Cylinder::clear_has_mass() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Cylinder::clear_mass() {
  mass_ = 1;
  clear_has_mass();
}
inline double Cylinder::mass() const {
  return mass_;
}
inline void Cylinder::set_mass(double value) {
  set_has_mass();
  mass_ = value;
}

// -------------------------------------------------------------------

// CylinderStamped

// optional .AssisiMsg.Header header = 1;
inline bool CylinderStamped::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CylinderStamped::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CylinderStamped::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CylinderStamped::clear_header() {
  if (header_ != NULL) header_->::AssisiMsg::Header::Clear();
  clear_has_header();
}
inline const ::AssisiMsg::Header& CylinderStamped::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::AssisiMsg::Header* CylinderStamped::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::AssisiMsg::Header;
  return header_;
}
inline ::AssisiMsg::Header* CylinderStamped::release_header() {
  clear_has_header();
  ::AssisiMsg::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void CylinderStamped::set_allocated_header(::AssisiMsg::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// required .AssisiMsg.Cylinder cylinder = 2;
inline bool CylinderStamped::has_cylinder() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CylinderStamped::set_has_cylinder() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CylinderStamped::clear_has_cylinder() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CylinderStamped::clear_cylinder() {
  if (cylinder_ != NULL) cylinder_->::AssisiMsg::Cylinder::Clear();
  clear_has_cylinder();
}
inline const ::AssisiMsg::Cylinder& CylinderStamped::cylinder() const {
  return cylinder_ != NULL ? *cylinder_ : *default_instance_->cylinder_;
}
inline ::AssisiMsg::Cylinder* CylinderStamped::mutable_cylinder() {
  set_has_cylinder();
  if (cylinder_ == NULL) cylinder_ = new ::AssisiMsg::Cylinder;
  return cylinder_;
}
inline ::AssisiMsg::Cylinder* CylinderStamped::release_cylinder() {
  clear_has_cylinder();
  ::AssisiMsg::Cylinder* temp = cylinder_;
  cylinder_ = NULL;
  return temp;
}
inline void CylinderStamped::set_allocated_cylinder(::AssisiMsg::Cylinder* cylinder) {
  delete cylinder_;
  cylinder_ = cylinder;
  if (cylinder) {
    set_has_cylinder();
  } else {
    clear_has_cylinder();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace AssisiMsg

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_base_5fmsgs_2eproto__INCLUDED
